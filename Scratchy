<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
  <title>Scratch Card — Responsive</title>
  <style>
    :root {
      --cover-color: #c8ccd1; /* overlay paint color */
      --cover-text: #3a3f45;  /* overlay text color */
      --hint-bg: rgba(0,0,0,.6);
      --hint-fg: #fff;
    }

    * { box-sizing: border-box; }
    html, body { height: 100%; margin: 0; background: #0b0f14; color: #e6e8ea; font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif; }

    .page {
      min-height: 100dvh;
      display: grid;
      place-items: center;
      padding: clamp(12px, 3vw, 32px);
    }

    .card {
      width: min(92vw, 680px);
      /* Let the height follow the media aspect ratio via the <img> below */
      position: relative;
      border-radius: 16px;
      overflow: hidden;
      box-shadow: 0 10px 30px rgba(0,0,0,.35);
      background: #11161c;
    }

    .media {
      display: block;
      width: 100%;
      height: auto;
      vertical-align: middle;
      user-select: none;
      -webkit-user-drag: none;
      touch-action: none; /* we'll control gestures */
    }

    canvas.overlay {
      position: absolute;
      inset: 0;
      width: 100%;
      height: 100%;
      display: block;
      /* ensure the canvas sits on top */
      pointer-events: auto;
    }

    .topbar {
      position: absolute; inset: 12px auto auto 12px; z-index: 3;
      background: var(--hint-bg);
      color: var(--hint-fg);
      padding: 6px 10px;
      border-radius: 999px;
      font-size: 12px;
      line-height: 1;
      display: flex; gap: 8px; align-items: center;
      backdrop-filter: blur(6px);
    }

    .controls {
      margin-top: 12px; display: flex; gap: 8px; flex-wrap: wrap; justify-content: center;
    }
    .btn {
      padding: 10px 14px; border-radius: 12px; border: 0; cursor: pointer; font-weight: 600;
      background: #1f2630; color: #e6e8ea; box-shadow: inset 0 0 0 1px rgba(255,255,255,.08);
    }
    .btn:active { transform: translateY(1px); }

    .footer-note { opacity: .7; font-size: 12px; text-align: center; margin-top: 8px; }
      .prize { position: absolute; inset: 0; display: grid; place-items: center; padding: clamp(12px,3vw,28px); text-align: center; z-index: 1; }
    .prize-inner { max-width: min(86ch, 90%); background: rgba(0,0,0,.45); border-radius: 16px; padding: clamp(12px,2.8vw,20px); backdrop-filter: blur(6px); box-shadow: 0 10px 30px rgba(0,0,0,.25); }
    .prize h2 { margin: 0 0 6px; font-size: clamp(18px, 5vw, 28px); font-weight: 800; letter-spacing: .2px; }
    .prize p { margin: 0; font-size: clamp(15px, 4.2vw, 20px); line-height: 1.35; }
    .controls .grow { flex: 1 1 auto; }
  </style>
</head>
<body>
  <div class="page">
    <div class="card" id="scratch-card">
      <div class="topbar" id="progress-pill">Scratch: <span id="pct">0%</span></div>
      <!-- Replace the src with your own image (CORS not required since it's under the canvas) -->
      <img id="bg" class="media" alt="Prize" src="https://images.unsplash.com/photo-1545239351-1141bd82e8a6?q=80&w=1600&auto=format&fit=crop" />
      <div class="prize" aria-live="polite">
        <div class="prize-inner">
          <h2 id="msg-title">A note for Eshu ❤️</h2>
          <p id="msg-text">(Scratch to reveal your message...)</p>
        </div>
      </div>
      <canvas id="cover" class="overlay" aria-label="Scratch overlay" role="img"></canvas>
    </div>

    <div class="controls">
      <button class="btn" id="prev">Prev</button>
      <button class="btn" id="next">Next</button>
      <button class="btn grow" id="shuffle">Shuffle</button>
      <button class="btn" id="reset">Reset</button>
      <button class="btn" id="reveal">Reveal</button>
    </div>
    <div class="footer-note">Works in portrait and landscape on mobile. Try rotating your phone.</div>
  </div>

  <script>
    // ===== Messages (from your Java-style array) =====
    const MESSAGES = [
"Heyyy Eshu, breathe. I’m always right here with you.",
"Missing me? I’m missing you more than you know.",
"You are safe, seen, and so so soodeeply loved.",
"It’s okay to feel upset my love. I’m holding space for you.",
"I choose you, every day, in every mood.",
"Your feelings matter to me. Always.",
"You don’t have to be strong alone aren't I part of your team.",
"If you need quiet, I’ll sit in it with you.",
"If you need to someone to talk to Eshu, you know I'm here.",
"You are my favourite person, even on the days we fight to argue.",
"Nothing about today changes how much I adore you.",
"You can text or call me any time baby, there's no ‘too late’ with us.",
"You’re allowed to feel everything. I’m not going anywhere.",
"I’m so proud of you eshu and everything you've done.",
"Your laugh is my favourite sound I’ll earn it back.",
"Annoyed? Is it my fault? We can fix this. I LOVE YOU!.",
"One hug from me is already on its way.",
"Close your eyes. Imagine my arms around you.",
"We’re a team. We face the day together.",
"You’re not a burden. You’re my blessing.",
"I believe in you. On good days and bad.",
"You’re doing better than you think.",
"I’m grateful for you, today and always.",
"Every storm passes. I’ll wait them out with you.",
"Let’s trade all our worries for some hugs when I see you next eshu.",
"Your heart is safe with me, it really is.",
"Thank you for being you. That’s enough.",
"Whatever you need, just say the word.",
"I’m on your side. Always.",
"Let me carry a little of that weight.",
"You deserve gentleness today.",
"I’m sending forehead kisses and soft smiles.",
"You’re my favourite hello and hardest goodbye.",
"I love your mind, your heart, your soul.",
"We’ll figure this out together.",
"I see your effort. I’m proud of it.",
"Your feelings are valid. No fixing needed right now.",
"Hold my hand even from far away.",
"You make my world softer and brighter.",
"If the day was heavy, let me be light.",
"Your smile is my mission today.",
"I’ll listen without interrupting, I promise. So talk to me.",
"You are not alone in this.",
"It’s okay to rest. I’ve got you.",
"I’m counting the minutes till I can hug you.",
"You are my peace, even in chaos.",
"Thank you for trusting me with your heart.",
"I love the way you care about everything.",
"You don’t have to earn love. You already have mine.",
"Let’s plan a cozy night soon baby just us.",
"We’ll laugh about this someday. Together.",
"I’m right here, holding you in my thoughts.",
"You are worthy of every good thing.",
"I’ll never stop choosing you.",
"Even when it’s messy, I’m yours.",
"I can’t wait to see your sleepy smile.",
"I admire your courage more than you know.",
"You make ordinary moments feel magical.",
"I’m cheering for you, always.",
"Let’s take it one tiny step at a time.",
"Your presence is my favourite gift.",
"I love how your eyes light up at little things.",
"You don’t have to explain just be with me.",
"Whatever happens, we’ll handle it together.",
"You’re my safe place too.",
"I love your beautiful heart every single day of the year.",
"You’re not too much. You’re just right for me.",
"I’m so so lucky to love you.",
"Your happiness matters so much to me.",
"Even oceans apart, you’re always close to me Eshu.",
"I will always make time for you.",
"You’re stronger than you feel today.",
"I’m grateful for every message from you.",
"Let’s press pause and cuddle (mentally, for now).",
"Your dreams matter, let’s chase them hand in hand.",
"I love your honesty, even when it’s hard.",
"You brighten my thoughts just by existing.",
"I won’t minimise what you feel. I’ll honour it.",
"You’re allowed a soft day. I’ll be soft with you.",
"I love our silly moments. More soon.",
"You’re precious to me. Full stop.",
"I see how hard you try. Thank you.",
"When you’re tired, lean on me my love.",
"I’ll be patient, just like you are with me. Take your time.",
"You’re my favourite human plot twist (LMAO idk what this is).",
"You make me want to be better, for us.",
"Let me warm your worries with kindness.",
"You’re the home I want to return to.",
"I’ll always root for your joy.",
"I love you in every mood you have.",
"We can restart this day together.",
"You and me: we’ve got this.",
"Your softness is strength. Keep it.",
"I love the way you love.",
"You’re enough, exactly as you are.",
"Let me make you tea and listen.",
"If you’re missing me, I’m missing you double.",
"I love loving you. It’s my favourite job.",
"I’m holding your hand in my heart right now.",
"You are my person. Always.",
"You make the hard parts worth it.",
"I adore you; today, tomorrow, always.",
"We’ll turn this page together.",
"I’m with you. Now and always."
];

    (function(){

      const img = document.getElementById('bg');
      const canvas = document.getElementById('cover');
      const ctx = canvas.getContext('2d');
      const pctEl = document.getElementById('pct');
      const btnReset = document.getElementById('reset');
      const btnReveal = document.getElementById('reveal');
      const btnPrev = document.getElementById('prev');
      const btnNext = document.getElementById('next');
      const btnShuffle = document.getElementById('shuffle');
      const msgText = document.getElementById('msg-text');
      const msgTitle = document.getElementById('msg-title');

      let idx = 0; // current message index
      function renderMessage() {
        msgText.textContent = MESSAGES[idx];
      }
      function nextMessage() { idx = (idx + 1) % MESSAGES.length; renderMessage(); resetOverlay(); }
      function prevMessage() { idx = (idx - 1 + MESSAGES.length) % MESSAGES.length; renderMessage(); resetOverlay(); }
      function shuffleMessage() { idx = Math.floor(Math.random() * MESSAGES.length); renderMessage(); resetOverlay(); }

      let isDown = false;
      let lastPoint = null;
      let scratchRadius = 28;      // logical pixels; scaled by DPR
      let revealThreshold = 55;     // % scratched to auto-reveal

      // Handle devicePixelRatio for crisp drawing
      function fitCanvasToElement() {
        const rect = canvas.getBoundingClientRect();
        const dpr = Math.max(1, window.devicePixelRatio || 1);
        // Only resize the canvas if CSS size changed significantly
        const cssW = Math.round(rect.width);
        const cssH = Math.round(rect.height);
        if (canvas.width !== Math.round(cssW * dpr) || canvas.height !== Math.round(cssH * dpr)) {
          canvas.width = Math.round(cssW * dpr);
          canvas.height = Math.round(cssH * dpr);
          ctx.setTransform(dpr, 0, 0, dpr, 0, 0); // scale coordinates to CSS pixels
          paintCover();
        }
      }

      function paintCover() {
        // Paint a solid cover and add centered text
        const { width, height } = canvas.getBoundingClientRect();
        ctx.globalCompositeOperation = 'source-over';
        ctx.clearRect(0, 0, canvas.width, canvas.height);

        // Base paint
        ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--cover-color').trim() || '#c8ccd1';
        ctx.fillRect(0, 0, width, height);

        // Add pattern-esque noise for a more scratchy feel
        addNoise(width, height);

        // Text
        ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--cover-text').trim() || '#3a3f45';
        ctx.font = `700 ${Math.max(18, Math.floor(width * 0.07))}px system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial`;
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText('Scratch to reveal', width / 2, height / 2);

        ctx.globalCompositeOperation = 'destination-out';
        updateProgress();
      }

      function addNoise(w, h) {
        const step = 12;
        ctx.save();
        ctx.globalAlpha = 0.08;
        for (let y = 0; y < h; y += step) {
          for (let x = 0; x < w; x += step) {
            const r = Math.random() * 6; // subtle
            ctx.fillStyle = `rgb(${200 + r*4}, ${200 + r*4}, ${200 + r*4})`;
            ctx.fillRect(x, y, step, step);
          }
        }
        ctx.restore();
      }

      function scratchAt(x, y) {
        const rect = canvas.getBoundingClientRect();
        const cx = x - rect.left; // CSS pixels due to transform
        const cy = y - rect.top;

        ctx.save();
        ctx.globalCompositeOperation = 'destination-out';
        ctx.lineCap = 'round';
        ctx.lineJoin = 'round';
        ctx.lineWidth = scratchRadius * 2;

        if (lastPoint) {
          ctx.beginPath();
          ctx.moveTo(lastPoint.x, lastPoint.y);
          ctx.lineTo(cx, cy);
          ctx.stroke();
        }
        // dot to ensure gaps are filled on taps
        ctx.beginPath();
        ctx.arc(cx, cy, scratchRadius, 0, Math.PI * 2);
        ctx.fill();
        ctx.restore();

        lastPoint = { x: cx, y: cy };
      }

      function handleDown(ev) {
        isDown = true;
        lastPoint = null;
        const p = getEventPoint(ev);
        scratchAt(p.x, p.y);
        updateProgressThrottled();
      }
      function handleMove(ev) {
        if (!isDown) return;
        const p = getEventPoint(ev);
        scratchAt(p.x, p.y);
        updateProgressThrottled();
      }
      function handleUp() {
        isDown = false;
        lastPoint = null;
        maybeAutoReveal();
      }

      function getEventPoint(ev) {
        if (ev.touches && ev.touches[0]) {
          return { x: ev.touches[0].clientX, y: ev.touches[0].clientY };
        }
        return { x: ev.clientX, y: ev.clientY };
      }

      // Progress calculation — sample pixels rather than full scan for speed
      function updateProgress() {
        try {
          const { width, height } = canvas;
          const sampleStep = 8; // higher -> faster but less precise
          const data = ctx.getImageData(0, 0, width, height).data;
          let cleared = 0, total = 0;
          for (let y = 0; y < height; y += sampleStep) {
            for (let x = 0; x < width; x += sampleStep) {
              const idx = (y * width + x) * 4 + 3; // alpha channel
              total++;
              if (data[idx] < 16) cleared++;
            }
          }
          const pct = Math.min(100, Math.max(0, Math.round((cleared / total) * 100)));
          pctEl.textContent = pct + '%';
          return pct;
        } catch (e) {
          // In case canvas becomes tainted (shouldn't, since we only draw overlay), fail gracefully
          return 0;
        }
      }

      const updateProgressThrottled = throttle(() => {
        const pct = updateProgress();
        if (pct >= revealThreshold) revealIfNotYet();
      }, 120);

      function revealIfNotYet() {
        if (!canvas.classList.contains('revealed')) {
          canvas.classList.add('revealed');
          // Fade-out animation using CSS opacity via JS (keeps canvas size intact)
          canvas.style.transition = 'opacity 380ms ease';
          canvas.style.opacity = '0';
          setTimeout(() => { canvas.style.display = 'none'; }, 420);
        }
      }

      function maybeAutoReveal() {
        const pct = updateProgress();
        if (pct >= revealThreshold) revealIfNotYet();
      }

      function resetOverlay() {
        canvas.classList.remove('revealed');
        canvas.style.display = 'block';
        canvas.style.opacity = '1';
        canvas.style.transition = '';
        paintCover();
        pctEl.textContent = '0%';
      }

      // Utilities
      function throttle(fn, wait) {
        let last = 0; let timer = null;
        return function(...args){
          const now = Date.now();
          const remaining = wait - (now - last);
          if (remaining <= 0) {
            clearTimeout(timer); timer = null; last = now; fn.apply(this, args);
          } else if (!timer) {
            timer = setTimeout(() => { last = Date.now(); timer = null; fn.apply(this, args); }, remaining);
          }
        };
      }

      // Events
      canvas.addEventListener('mousedown', handleDown);
      window.addEventListener('mousemove', handleMove);
      window.addEventListener('mouseup', handleUp);

      canvas.addEventListener('touchstart', (e) => { e.preventDefault(); handleDown(e); }, { passive: false });
      window.addEventListener('touchmove', (e) => { e.preventDefault(); handleMove(e); }, { passive: false });
      window.addEventListener('touchend', handleUp, { passive: true });

      btnReset.addEventListener('click', resetOverlay);
      btnReveal.addEventListener('click', revealIfNotYet);
      btnNext.addEventListener('click', nextMessage);
      btnPrev.addEventListener('click', prevMessage);
      btnShuffle.addEventListener('click', shuffleMessage);

      // Keep canvas perfectly aligned over the <img> regardless of orientation/size changes
      const ro = new ResizeObserver(() => fitCanvasToElement());
      ro.observe(img);
      window.addEventListener('orientationchange', () => setTimeout(fitCanvasToElement, 250));
      window.addEventListener('resize', throttle(fitCanvasToElement, 100));

      // When image loads, size canvas and paint cover
      if (img.complete) {
        fitCanvasToElement();
        paintCover();
      } else {
        img.addEventListener('load', () => { fitCanvasToElement(); paintCover(); });
      }
      // Initial message
      renderMessage();

      // Optional: tweak brush size a bit based on viewport
      function setBrushByViewport() {
        const w = Math.min(window.innerWidth, document.getElementById('scratch-card').clientWidth);
        scratchRadius = Math.max(18, Math.round(w / 24));
      }
      setBrushByViewport();
      window.addEventListener('resize', throttle(setBrushByViewport, 120));

    })();
  </script>
</body>
</html>
